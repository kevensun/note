####gcc工作流程   
1. 预处理  gcc -E  
2. 编译    gcc -S  
3. 汇编    gcc -c  
4. 链接    没参数    
   
-o:指定生成的文件的名字  
-D：在编译的时候定义宏(控制log输出)
-I：指定头文件的路径  
-g：gdb调试的时候需要添加该参数  
-O：编译优化，3个等级
-Wall：编译期间输出警告信息   
***   
####制作静态库    
1. 命名规则：libMyName.a  
2. 制作步骤   
	2.1 生成.o  
		gcc -c *.c
	2.2 打包(将所有的.o文件)
		ar rcs 静态库的名字*.o
3. 使用：main.c -L -l  
	gcc main.c  -LlibPath -llibname -o app -Iinclude   
***   
####制作动态库   
1. 动态库后缀.so   
2. 制作步骤  
	2.1 生成与位置无关的代码.o  
		gcc -fPIC -c *.c -Iinclude   
 	2.2 将.o打包生成.so文件   
		gcc -shared -o libmytest.so *.o   
3. 使用main.c lib include   
	gcc main.c -Llib -lmytest -Iinclude -o app  
应用程序不能执行，动态链接器链接不到自己制作的库  
1. 临时设置的方法： 
	export LD_LIABRARY_PATH=./lib
2. 永久设置的方法：
	2.1 找到动态链接库的配置文件：/etc/ld.so.conf  
	2.2 在该文件中添加动态库的目录(绝对路径)
	2.3 更新: sudo ldconfig -v   
***  
####gdb调试   
1. 启动gdb  
	start  只执行一步  
	n      next   
	s      step(单步) 可以进入到函数体内部   
	c      continue  直接停在断电位置
	finish 跳出函数体 
	u      跳出循环  
2. 查看代码   
	l    list
3. 设置断点   
	b   break    
	设置条件断点 b 10 if value == 189  
   删除断点   d  断点编号   
	info  b   
	display   自动打印变量值
	ptype     获取变量对应的类型
***   
####CPU为什么要使用虚拟地址空间与物理地址空间映射？解决了什么问题？    
1. 方便编译器和操作系统安排程序的地址分配   
	程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区   
2. 方便进程之间隔离  
	不同进程使用的虚拟地址彼此隔离，一个进程中的代码无法更改正在由另一进程使用的物理内存   
3. 方便OS使用你那可怜的内存   
	程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页(通常大小为4K)保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘直接移动    
***   
####Makefile   
1. 一个规则   
	三要素：目标 依赖 命令   
	1.1 第一条规则是用来生成终极目标的规则  
2. 两个函数   
	2.1 查找指定目录下，指定类型的文件
        src=$(wildcard ./*.c)
	2.2 匹配替换函数  
		obj=$(patsubst %.c,%.o,$(src))	
3. 三个自动变量
	3.1 $<规则中的第一个依赖  
	3.2 $^规则中的所有依赖  
	3.3 $@规则中的目标    
***  
####Linux系统IO函数   
1. 文件描述符   int类型 最多1024
2. pcb    进程控制块
3. 虚拟地址空间  
	用户区 内核区   
***   
每个进程都有一个且只有一个定时器   
使用time命令查看程序执行的时间    
程序运行的瓶颈在于IO，优化程序，首选优化IO    
实际执行时间=系统时间+用户时间+等待时间   
setitimer函数，精度微妙，可以实现周期定时   
***    
定义可重入函数，函数内不能含有全局变量及static变量，不能使用malloc、free
 


	


