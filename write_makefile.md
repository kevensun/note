###概述  
* 预处理  
* 汇编 
* 编译
* 链接  

反斜杠 \ 表示换行
***  
GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令；只要看到一个.o文件，它就会自动的把.c文件加在依赖关系中，并且cc -c whatever.c也会被推导出来，这种方法也就是make的隐晦规则。 
*** 
 
-rm test $(objects):在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。
***  
Makefile里主要包含了五个东西：显式规则、隐晦规则(自动推导)、变量定义(字符串，类似宏)、文件指示和注释(#)  
#####文件指示  
1. 在一个Makefile中引用另一个Makefile，就像C语言中的include；
2. 根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样
3. 定义一个多行的命令

***  
###GNU的make工作时的执行步骤：
1. 读入所有的Makefile；
2. 读入被include的其他makefile；
3. 初始化文件中的变量；
4. 推导隐晦规则，并分析所有规则；
5. 为所有的目标文件创建依赖关系链；
6. 根据依赖关系，决定哪些目标要重新生成；
7. 执行生成命令。

***  
>objects :=*.o  
  
上面这个例子表示了通配符同样可以用在变量中。并不是说\*.o会展开，不！objects的值就是\*.o。Makefile中的变量其实就是C、C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有.o的文件名的集合，那么，你可以这样：  
>objects:=$(wildcard *.o)  

*** 
###生成多个目标  
>all:prog1 prog2 prog3  

***  
###显示命令  
通常，make会把其要执行的命令行在执行前输出到屏幕上。当我们用@字符在命令行前，那么，这个命令将不被显示出来。  

***  
###嵌套执行make 
总控Makefile可以这样写  
 
		subsystem:
			cd subdir && $(MAKE)
其等价于  
 
		subsystem:
			$(MAKE) -C subdir  
***  
- := 前面的变量不能使用后面的变量  
- ?= 如果变量没有被定义过，则赋值,如果变量先前被定义过，那么这条语句将什么也不做  
- += 追加赋值  
***  
####替换  

			foo:=a.o b.o c.o  
			bar:=$(foo:.o=.c)
 
把$(foo)中所有以.o结尾的子串替换成.c  
***  
####字符串处理函数  
字符串替换： 

		$(subst <from>,<to>,<text>) 
		$(patsubst <pattern>,<replacement>,<test>)  

去掉string开头和结尾的空字符：  

		$(strip <string>)  

		$(foreach <var>,<list>,<text>):  

把参数list中的单词逐一取出放到参数var所指定的变量中，然后再执行text所包含的表达式。每一次text会返回一个字符串，循环过程中，text的所返回的每个字符串会以空格分隔，最后当整个循环结束时，text所返回的每个字符串所组成的整个字符串(以字符分隔)将会是foreach函数的返回值  

### 常用隐含规则  
1. 编译C程序的隐含规则：n.o的目标的依赖目标会自动推导为n.c，并且生成命令是 $(CC) -c $(CPPFLAGS) $(CFLAGS)
2. 编译C++程序的隐含规则：n.o的目标的依赖目标会自动推导为n.cc或是n.C,并且其生成命令是$(CXX) -c $(CPPFLAGS) $(CFLAGS)  

***  
###隐含规则中的变量  
####关于命令的变量  
AR 函数库打包程序，默认ar  
AS 汇编语言编译程序，默认as  
CC C语言编译程序，默认cc  
CXX C++语言编程程序，默认g++  

    
  




  


